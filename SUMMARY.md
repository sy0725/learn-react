###### [학습 주제](./PLAN.md) 보기

# 8. 29

- Zustand 라이브러리는 가장 스타를 많이 받은 상태 관리 도구이다.
- Immer 라이브러리를 함께 사용하면 상태 관리가 편해진다. (중첩된 상태일 수록 빛)
- 미들웨어(persist, immer, devtools)를 사용한 유틸리티히 함수를 사용하면 스토어 생성이 편하다.
- Ramda 라이브러리의 pipe 함수를 사용하면 미들웨어 관리가 편하다.

# 8. 28

- 컴포넌트를 추출해 관리하는 것이 코드 유지보수에 좋다.
- 스타일 모듈 또한 별도 분리해 관리한다면 컴포넌트는 마크업과 로직만 담당하게 된다.
- useState() 훅에 함수를 설정하면 지연된 초기화 후 초기값을 설정할 수 있다.
- 로그인 상태에서 페이지를 새로고침할 때 인증 상태 확인에 시간이 소요되므로 확인 후, 처리해야 한다.
- PocketBase 데이터베이스는 관계 확장을 지원한다.
- Zustand 라이브러리를 사용하면 앱 상태 관리가 수월해진다.
    - 공급자(Provider) 제공이 없다.
    - Redux나 Context 보다 예열 코드가 거의 없다.


# 8. 25 

- 타입 검사 필요할까? (권장)
    - JavaScript를 사용해 React 앱을 개발한다면? prop-types 패키지 사용을 권장한다. (props 검사만 가능)
    - TypeScript를 사용해 React 앱을 개발한다면? 강력한 타입 검사 시스템을 사용해 코드 품질을 높일 수 있다.
- 로컬 스토리지를 사용해 인증 상태를 유지(persist)할 수 있다.
- 인증 상태에서만 접속 가능한 루트(route)를 보호(protect)해야 한다.
- PocketBase 데이터베이스에 파일을 업로드 하려면 JSON이 아니라, FormData를 사용해야 한다.
- 클라이언트(브라우저) 환경에서 업로드할 이미지를 표시할 경우 `URL.createObjectURL(file)`을 사용한다.
- useMemo() 훅은 JavaScript의 모든 데이터 유형을 기억(memoization)한다.
- useCallback() 훅은 JavaScript 함수 유형만 기억한다. 
- useMemo() 훅을 사용해 함수 유형 값을 기억할 수도 있지만, useCallback() 훅을 사용하는 것이 문장 구문이 간결하다. ([답변 참고](https://www.notion.so/useMemo-VS-useCallback-e546342310fc4ce492d22d272ec343d1?pvs=4#5f497e3b1dca4a67b732ad3139f5618c))


# 8. 24

1. Refs를 활용해 값을 참조해 기억하거나, DOM 요소를 참조할 수 있습니다.
1. [GSAP](https://greensock.com/gsap/) 애니메이션 라이브러리는 명령형 방식으로 작성해야 합니다. (`useRef` + `useLayoutEffect`(with cleanup))
1. React 18+부터 지원하는 동시성 렌더링 모드 영향으로 GSAP 컨텍스트([`gsap.context()`](https://greensock.com/docs/v3/GSAP/gsap.context()))를 사용해야 스크린 티어링(screen tearing) 현상을 해결할 수 있습니다.
1. [Framer Motion](https://framer.com/motion)은 React 전용 애니메이션 라이브러리로 선언형 프로그래밍 방식으로 작성합니다. 
1. 고유한 `key` 속성(prop) 설정은 컴포넌트 (또는 애니메이션) 초기화에 사용될 수 있습니다. 
1. PocketBase AuthStore를 사용해 로그인 상황을 체크하거나, 로그아웃 등 기능을 사용할 수 있습니다.
1. React Context API를 사용해 인증 상황을 앱에 공급할 수 있습니다.
1. `useAuth` 커스텀 훅을 사용하면 앱 어디서나 인증 상황을 주입받을 수 있습니다.
1. 루트 보호(Protected Route) 컴포넌트는 인증된 사용자만 접근 가능하도록 처리합니다. 
1. [react-hot-toast](https://react-hot-toast.com/docs/toast) 라이브러리를 사용해 손쉽게 사용자에게 공지(Notification)할 수 있습니다.


# 8. 23

1. 리액트는 기본적으로 단방향 데이터 흐름에 따라 작동합니다. (Top Down Approach)
1. 리액트는 하위 컴포넌트에 속성(props)을 전달해 데이터를 공유할 수 있습니다.
1. 컴포넌트가 가진 상태는 컴포넌트 또는 포함한 컴포넌트만 접근이 가능하기에 형제 또는 상위 컴포넌트와는 공유할 수 없습니다.
1. 그러므로 상태를 공유하려는 컴포넌트들의 공통 상위 컴포넌트로 끌어올려야 상태를 공유할 수 있습니다.
1. 다만, 데이터를 공유해야 할 컴포넌트 트리의 깊이가 깊어질수록 상태 관리가 어려워집니다.
1. 이러한 현상을 나사로 드릴(drill, 뚫다)질하는 것 같다하여 "프롭스 드릴링(Props Drilling)"이라고 부릅니다.
1. 리액트는 이러한 문제 해결의 수단으로 특정 영역(Context) 안에서 상태를 바로 공급할 수 있는 Context API를 제공합니다.
1. 컨텍스트를 사용하려면 먼저 생성해야 합니다. `React.createContext()`
1. 생성된 컨텍스트를 통해 공급자 컴포넌트를 사용할 수 있습니다. `<Context.Provider />`
1. 공급자 컴포넌트는 `value` 속성(prop)을 사용해 깊숙히 위치한 하위 컴포넌트에 값을 공급합니다.
1. `useContext()` 훅을 사용하면 공급된 값을 영역 내 어느 컴포넌트나 가져와 사용할 수 있습니다. 
1. 컨텍스트는 컴포넌트 내부에 포함되지 않아도 됩니다. 별도 분리하여 관리할 수도 있습니다. `src/contexts/Theme.jsx`
1. 컨텍스트 공급자(Context.Provider)를 감싸는 래퍼 컴포넌트를 사용하면 코드를 캡술화하여 관리할 수 있습니다.
1. 컨텍스트 값을 쉽게 꺼내올 수 있도록 사용자가 훅을 정의해 사용할 수도 있습니다. `useTheme`
1. `useRef()` 훅은 컴포넌트 렌더링에 영향을 주지 않으면서 값을 업데이트(그것도 뮤테이션 방식으로)할 수 있습니다.
1. `useRef()`를 통해 참조된 값을 변경해도 컴포넌트는 리-렌더링 되지 않습니다. 


# 8. 22

1. PocketBase 데이터베이스와 통신해 데이터를 읽기/쓰기/수정/삭제 할 수 있습니다.
1. 폼 상태(Form State)는 개별적으로 관리할 수도 있지만, 한데 묶어서 관리할 수 있습니다.
1. PocketBase 인증(Authentication)을 사용해 회원가입, 로그인 기능을 사용할 수 있습니다.
1. 회원가입(Signup) 페이지와 로그인 페이지의 폼은 유사합니다. (재사용 가능한 컴포넌트를 활용)


# 8. 21

1. 이미지는 크게 정적(public 폴더), 동적(src 안에 있는 assets 폴더)으로 처리합니다.
1. 동적 이미지의 경우는 반드시 import 구문으로 이미지 경로를 불러와야 합니다.
1. 정적 이미지의 경우 배포하기 전에는 `/`로 사용합니다.
1. 리액트 라우터를 사용하면 루트 파라미터(route parameters)를 사용해 동적 라우팅(dynamic routing)할 수 있습니다.
1. 동적 라우팅 사용 시, 루트 파라미터는 콜론(`:`)을 사용해 표기합니다.


# 8. 18

1. 커스텀 훅(Custom Hook)을 사용해 재사용할 로직(logic)을 분리할 수 있습니다.
1. React Router를 사용하면 싱글 페이지 애플리케이션을 만들 수 있습니다.


# 8. 17

1. 사이드 이펙트를 관리하는 이벤트 핸들러 및 useEffect 훅의 콜백 함수를 실습하고 요약 정리합니다.
    - 이펙트 콜백 함수 (effect callback function)
    - 이펙트 콜백 함수 실행 조건 설정 (dependencies)
    - 이펙트 클린업 함수 (cleanup)
1. 서버 데이터 요청/응답
    - 데이터 가져오기(fetch Data)
        - Fetch API 활용
    - useEffect 훅을 사용해 데이터 가져오기 상태 설정
        - 대기(pending)
        - 로딩(loading)
        - 성공(success)
        - 실패(error)
    - Async 함수를 사용하는 방법
1. PocketBase 백엔드 데이터베이스 솔루션
    - 다운로드 및 서버 구동
    - 콜렉션, 레코드, 필드 개념 이해
    - 콜렉션 생성, 필드 추가
    - API 규칙 설정 (접근 권한)


# 8. 16

1. Tailwind CSS 설치 및 구성(with 플러그인) 실습을 진행하였습니다.
1. 데이터 유형(number, string, boolean, array, object) 별 React 상태 관리 방법을 실습하였습니다.
1. 용도에 따라 폼 입력 필드의 `value`, `defaultValue`, `readOnly`, `onChange` 설정 방법을 다뤘습니다.
1. 상태(state)와 파생된 상태(derived state)를 사용해 사용자 인터페이스를 구성하고 사용자와 상호작용합니다.
1. 쌍(pair)으로 관리될 필요가 있는 상태는 그룹(group)으로 관리하는 것이 좋습니다.
1. 복잡한 데이터인 객체 또는 배열을 상태로서 관리할 때는 합성 방식을 사용해야 합니다.
1. 배열 데이터를 관리할 때 배열(집합)과 선택된 상태(단수) 2가지 상태로 UI를 구현할 수 있습니다.


# 8. 14

## 컴포넌트 상태 관리 요약

1. JavaScript 로컬 변수를 사용하면 React 컴포넌트 상태 관리가 가능하지 않습니다.
1. React가 제공하는 useState 훅을 사용해야 상태 관리가 가능합니다.
1. useState 훅은 배열을 반환하는데 첫번째 항목은 상태, 두번째 항목은 상태 업데이트 함수입니다.
1. useState 훅이 반환한 상태 업데이트 함수가 실행되면 React에게 렌더 트리거(render trigger) 합니다.
1. 렌더 트리거는 컴포넌트를 다시 실행시킵니다. (리-렌더링 발생)
1. 일반 로컬 변수는 함수 재실행 과정에서 초기화되지만, useState에서 추출된 상태는 이전의 값을 기억합니다.
1. 컴포넌트 내부에서 상태를 관리하는 것이 가능합니다. useState 훅을 사용해 여러 상태를 관리할 수 있습니다.
1. 상태 업데이트 함수는 사용법이 2가지인데 하나는 다음 상태(nextState) 값을 직접 전달하는 것이고, 다른 하나는 [set 함수](https://react.dev/reference/react/useState#setstate)를 사용하는 것입니다.
1. set 함수를 사용한 업데이트는 이전 상태 값을 토대로 계산된 다음 상태 값을 반환해야 합니다.

## 사이드 이펙트 요약

1. 렌더링 단계(렌더 트리거 → 컴포넌트 렌더링 → DOM 커밋) 중 DOM 커밋 시점에 실행(콜백)되는 로직에서는 사이드 이펙트 처리 가능
1. 사이드 이펙트는 DOM 커밋 이후에 실행되어야 한다. (접근성, 요소의 스타일 변경, 모든 명령형 프로그래밍 코드)
1. 사이드 이펙트 로직을 허용하는 영역은 2가지 (이벤트 핸들러, useEffect 훅의 이펙트 콜백 함수)

## 컴포넌트 순수성 유지 요약

1. 컴포넌트 렌더링 단계에 영향을 미치지 않도록 순수함을 유지해야 합니다.
1. 사이드 이펙트(부수 효과)를 유발하는 코드를 함수 몸체(body) 안에 작성해서는 안됩니다.
1. 동일 입력, 동일 출력을 지켜야 합니다. (props(읽기 전용) → JSX 반환)
1. StrictMode 컴포넌트의 역햘은 계산이 순수한지 확인하는 것입니다. (2번씩 렌더링)
1. StrictMode는 배포(production) 모드에서 제거되므로 성능에 영향을 주지 않습니다.
1. 로컬 뮤테이션은 컴포넌트 함수 내부에서 이뤄져도 문제가 되지 않습니다.


# 8. 11

## CSS 모듈 요약

1. CSS 클래스 코드를 모듈 객체로 받아와 고유한 이름을 사용할 수 있습니다.
1. 다른 사람이 작성한 클래스 이름과 절대로 충돌할 일이 없다.
1. 컴포넌트 스타일을 보호할 수 있다.
1. 사용자 정의 클래스 모듈 이름을 설정할 수 있다. ([참고](https://vitejs.dev/config/shared-options.html#css-modules))

## 이벤트 핸들링 요약

1. 리액트 컴포넌트에 이벤트 연결하기 (`onclick` ❌, `onClick` ✅)
1. 모든 props를 예측해서 컴포넌트에 적용하기란 쉽지 않다. (그래서 `restProps`를 활용)
1. 이벤트 핸들러(리스너) 로직 구성 (DOM 스크립팅 → 사이드 이펙트, 불순 함수 허용)
1. 사이드 이펙트란? React 렌더링 과정과 관련 없는 것들(부수적인 것)을 말합니다.


# 8. 10

## 리스트 렌더링 요약

1. 배열 순환 리스트 렌더링
1. 배열 역순으로 정렬한 다음 리스트 렌더링 (원본 배열을 변경하면 안됨, 배열 복사 또는 새로운 배열 반환 메서드)
1. 객체 순환 리스트 렌더링 (객체 → 배열 객체로 변경 → map 메서드로 순환)
1. `<dl>` 내부에 `<div>`를 사용하는 것이 적절한 지 고민한 후 적절하지 않으면 `<></>`를 사용 
1. `<></>`의 경우 리스트 렌더링 시 `key` prop을 설정할 수 없음. 그러므로 `<React.Fragment key={} />` 활용해야 함